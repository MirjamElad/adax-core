"use strict";var k=Object.defineProperty,E=Object.defineProperties,O=Object.getOwnPropertyDescriptor,z=Object.getOwnPropertyDescriptors,B=Object.getOwnPropertyNames,S=Object.getOwnPropertySymbols;var M=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable;var T=(e,r,t)=>r in e?k(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,R=(e,r)=>{for(var t in r||(r={}))M.call(r,t)&&T(e,t,r[t]);if(S)for(var t of S(r))$.call(r,t)&&T(e,t,r[t]);return e},b=(e,r)=>E(e,z(r));var j=(e,r)=>{for(var t in r)k(e,t,{get:r[t],enumerable:!0})},I=(e,r,t,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let l of B(r))!M.call(e,l)&&l!==t&&k(e,l,{get:()=>r[l],enumerable:!(n=O(r,l))||n.enumerable});return e};var N=e=>I(k({},"__esModule",{value:!0}),e);var U={};j(U,{KernelStore:()=>f,addQuery:()=>y,addRule:()=>C,afterWrite:()=>m,clearAllRules:()=>P,getExecStack:()=>D,getQueryPlan:()=>v,getSortedID:()=>w,kernelStore:()=>i,removeQuery:()=>g,removeRule:()=>F,subscribe:()=>L,trigger:()=>A});module.exports=N(U);var d=class{constructor({rules:r,queries:t,reverseRules:n}={rules:new Map,queries:new Map,reverseRules:new Map}){this.runAllQueries=!1;this.execStack=[];this.getSortedID=()=>(!d.incrCpt&&typeof sessionStorage!="undefined"&&(d.sessionCpt=Number(sessionStorage.getItem("adax-sessionCpt"))||0,sessionStorage.setItem("adax-sessionCpt",`${d.sessionCpt+1}`)),`${d.sessionCpt}-${new Date().getTime().toString(36)}-${d.incrCpt++}`);this.rules=r,this.queries=t,this.reverseRules=n,d.instances.push(this)}static getAllInstances(){return d.instances}},f=d;f.incrCpt=0,f.sessionCpt=0,f.instances=[];var i=new f;var C=({writeFn:e,queryFn:r,skip:t},n={kernel:i})=>{n.kernel.rules.has(e)||n.kernel.rules.set(e,{readersMap:new Map});let l=n.kernel.rules.get(e);l.readersMap.has(r)||l.readersMap.set(r,t),n.kernel.reverseRules.has(r)||n.kernel.reverseRules.set(r,new Set);let a=n.kernel.reverseRules.get(r);a.has(e)||a.add(e)},F=({writeFn:e,queryFn:r},t={kernel:i})=>{let n=t.kernel.rules.get(e);n!=null&&n.readersMap.has(r)&&(n.readersMap.delete(r),n.readersMap.size==0&&t.kernel.rules.delete(e));let l=t.kernel.reverseRules.get(r);l!=null&&l.has(e)&&(l.delete(e),l.size||t.kernel.reverseRules.delete(r))},P=(e={kernel:i})=>{e.kernel.rules.clear(),e.kernel.reverseRules.clear()},y=({queryFn:e,queryInstance:r},t={kernel:i})=>(t.kernel.queries.has(e)||t.kernel.queries.set(e,new Map),t.kernel.queries.get(e).set(r.instanceKey,r),r),g=({queryFn:e,queryInstance:r},t={kernel:i})=>{let n=t.kernel.queries.get(e);n&&(n.delete(r.instanceKey),n.size||t.kernel.queries.delete(e))},m=({writeFn:e,writeParamsObj:r,queryPlan:t},n={kernel:i})=>{n.kernel.execStack.push({name:e.name,writeFn:e,writeParamsObj:r,queryPlan:t})};var Q=e=>e===m;var W=(e,r)=>{let t,n=0;return(...l)=>{let p=new Date().getTime(),u=p-n;u<r?(clearTimeout(t),t=setTimeout(()=>{e.apply(void 0,l)},r-u)):e.apply(void 0,l),n=p}},K=(e,r)=>{let t;return(...n)=>{let a=Array.prototype.slice.call(n);t&&clearTimeout(t),t=setTimeout(()=>{e.apply(void 0,a)},r)}};var D=(e=null,r={kernel:i})=>{var t;return((t=r==null?void 0:r.kernel)==null?void 0:t.execStack)||[]},V=(e,r)=>{e.result.prevData=e.result.data,e.result.data=r(e.paramsObj),e.result.version=e.result.version+1},J=e=>{var r,t;(!((r=e.options)!=null&&r.hasResultChanged)||(t=e.options)!=null&&t.hasResultChanged(e.result.prevData,e.result.data))&&e.readTrigger(e.result)},h=(e,r,t=[],n=[],l,a,p=void 0)=>{var u,o;(o=(u=e.kernel.queries)==null?void 0:u.get(a))==null||o.forEach(s=>{if(!(s!=null&&s.readTrigger))return;r.has(a)||r.set(a,new Array);let c=r.get(a),x=p&&p(l,s.paramsObj);s.result=(s==null?void 0:s.result)||{version:0,data:void 0,prevData:void 0},!x&&(s!=null&&s.readTrigger)&&(t.push(()=>{V(s,a)}),n.push(()=>{s!=null&&s.readTrigger&&J(s)})),c.push(b(R({},s),{skip:!!x}))})},v=({writeFn:e,writeParamsObj:r},t={kernel:i})=>{let n=new Map,l=[],a=[];if(!t.kernel.runAllQueries&&t.kernel.rules.has(e)){let o=t.kernel.rules.get(e).readersMap;o!=null&&o.size&&(o==null||o.forEach((s,c)=>{h(t,n,l,a,r,c,s)})),t.kernel.queries.size>t.kernel.reverseRules.size&&t.kernel.queries.forEach((s,c)=>{t.kernel.reverseRules.has(c)||h(t,n,l,a,r,c)})}else Q(e)||t.kernel.queries.forEach((o,s)=>{h(t,n,l,a,r,s)});return{queryPlan:n,computeData:()=>{l.forEach(o=>o())},triggerViews:()=>{a.forEach(o=>o())}}};var w=i.getSortedID,A=(e,r,t={kernel:i})=>{let{queryPlan:n,computeData:l,triggerViews:a}=v({writeFn:e,writeParamsObj:r},t);e(r),l(),setTimeout(()=>{a(),Q(e)||A(m,{writeFn:e,writeParamsObj:r,queryPlan:n},t)})},L=(e,r,t,n={},l={kernel:i})=>{var c;let a=(c=n.cmpId)!=null?c:w(),p={data:n!=null&&n.skipInitalQuerying?void 0:r(t),prevData:void 0,version:0},u=e;if(n.debounceMs||n.throttleMs){if(n.debounceMs&&n.throttleMs)throw new Error("Cannot have both debounce and throttle options for any given query!");n.debounceMs?u=K(e,n.debounceMs):n.throttleMs&&(u=W(e,n.throttleMs))}return{result:p,onMounted:()=>{y({queryFn:r,queryInstance:{instanceKey:a,readTrigger:u,paramsObj:t||{},options:n,result:p}},l)},onBeforeUnmount:()=>{g({queryFn:r,queryInstance:{instanceKey:a,readTrigger:void 0,paramsObj:t||{},options:n,result:{data:void 0,prevData:void 0,version:0}}},l)}}};0&&(module.exports={KernelStore,addQuery,addRule,afterWrite,clearAllRules,getExecStack,getQueryPlan,getSortedID,kernelStore,removeQuery,removeRule,subscribe,trigger});
