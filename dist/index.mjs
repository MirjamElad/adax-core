var C=Object.defineProperty,F=Object.defineProperties;var P=Object.getOwnPropertyDescriptors;var x=Object.getOwnPropertySymbols;var W=Object.prototype.hasOwnProperty,K=Object.prototype.propertyIsEnumerable;var S=(e,r,t)=>r in e?C(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,T=(e,r)=>{for(var t in r||(r={}))W.call(r,t)&&S(e,t,r[t]);if(x)for(var t of x(r))K.call(r,t)&&S(e,t,r[t]);return e},M=(e,r)=>F(e,P(r));var d=class{constructor({rules:r,queries:t,reverseRules:n}={rules:new Map,queries:new Map,reverseRules:new Map}){this.runAllQueries=!1;this.execStack=[];this.getSortedID=()=>(!d.incrCpt&&typeof sessionStorage!="undefined"&&(d.sessionCpt=Number(sessionStorage.getItem("adax-sessionCpt"))||0,sessionStorage.setItem("adax-sessionCpt",`${d.sessionCpt+1}`)),`${d.sessionCpt}-${new Date().getTime().toString(36)}-${d.incrCpt++}`);this.rules=r,this.queries=t,this.reverseRules=n,d.instances.push(this)}static getAllInstances(){return d.instances}},f=d;f.incrCpt=0,f.sessionCpt=0,f.instances=[];var o=new f;var D=({writeFn:e,queryFn:r,skip:t},n={kernel:o})=>{n.kernel.rules.has(e)||n.kernel.rules.set(e,{readersMap:new Map});let l=n.kernel.rules.get(e);l.readersMap.has(r)||l.readersMap.set(r,t),n.kernel.reverseRules.has(r)||n.kernel.reverseRules.set(r,new Set);let a=n.kernel.reverseRules.get(r);a.has(e)||a.add(e)},w=({writeFn:e,queryFn:r},t={kernel:o})=>{let n=t.kernel.rules.get(e);n!=null&&n.readersMap.has(r)&&(n.readersMap.delete(r),n.readersMap.size==0&&t.kernel.rules.delete(e));let l=t.kernel.reverseRules.get(r);l!=null&&l.has(e)&&(l.delete(e),l.size||t.kernel.reverseRules.delete(r))},A=(e={kernel:o})=>{e.kernel.rules.clear(),e.kernel.reverseRules.clear()},y=({queryFn:e,queryInstance:r},t={kernel:o})=>(t.kernel.queries.has(e)||t.kernel.queries.set(e,new Map),t.kernel.queries.get(e).set(r.instanceKey,r),r),g=({queryFn:e,queryInstance:r},t={kernel:o})=>{let n=t.kernel.queries.get(e);n&&(n.delete(r.instanceKey),n.size||t.kernel.queries.delete(e))},m=({writeFn:e,writeParamsObj:r,queryPlan:t},n={kernel:o})=>{n.kernel.execStack.push({name:e.name,writeFn:e,writeParamsObj:r,queryPlan:t})};var k=e=>e===m;var R=(e,r)=>{let t,n=0;return(...l)=>{let p=new Date().getTime(),u=p-n;u<r?(clearTimeout(t),t=setTimeout(()=>{e.apply(void 0,l)},r-u)):e.apply(void 0,l),n=p}},b=(e,r)=>{let t;return(...n)=>{let a=Array.prototype.slice.call(n);t&&clearTimeout(t),t=setTimeout(()=>{e.apply(void 0,a)},r)}};var E=(e=null,r={kernel:o})=>{var t;return((t=r==null?void 0:r.kernel)==null?void 0:t.execStack)||[]},O=(e,r)=>{e.result.prevData=e.result.data,e.result.data=r(e.paramsObj),e.result.version=e.result.version+1},z=e=>{var r,t;(!((r=e.options)!=null&&r.hasResultChanged)||(t=e.options)!=null&&t.hasResultChanged(e.result.prevData,e.result.data))&&e.readTrigger(e.result)},Q=(e,r,t=[],n=[],l,a,p=void 0)=>{var u,i;(i=(u=e.kernel.queries)==null?void 0:u.get(a))==null||i.forEach(s=>{if(!(s!=null&&s.readTrigger))return;r.has(a)||r.set(a,new Array);let c=r.get(a),h=p&&p(l,s.paramsObj);s.result=(s==null?void 0:s.result)||{version:0,data:void 0,prevData:void 0},!h&&(s!=null&&s.readTrigger)&&(t.push(()=>{O(s,a)}),n.push(()=>{s!=null&&s.readTrigger&&z(s)})),c.push(M(T({},s),{skip:!!h}))})},v=({writeFn:e,writeParamsObj:r},t={kernel:o})=>{let n=new Map,l=[],a=[];if(!t.kernel.runAllQueries&&t.kernel.rules.has(e)){let i=t.kernel.rules.get(e).readersMap;i!=null&&i.size&&(i==null||i.forEach((s,c)=>{Q(t,n,l,a,r,c,s)})),t.kernel.queries.size>t.kernel.reverseRules.size&&t.kernel.queries.forEach((s,c)=>{t.kernel.reverseRules.has(c)||Q(t,n,l,a,r,c)})}else k(e)||t.kernel.queries.forEach((i,s)=>{Q(t,n,l,a,r,s)});return{queryPlan:n,computeData:()=>{l.forEach(i=>i())},triggerViews:()=>{a.forEach(i=>i())}}};var B=o.getSortedID,$=(e,r,t={kernel:o})=>{let{queryPlan:n,computeData:l,triggerViews:a}=v({writeFn:e,writeParamsObj:r},t);e(r),l(),setTimeout(()=>{a(),k(e)||$(m,{writeFn:e,writeParamsObj:r,queryPlan:n},t)})},ne=(e,r,t,n={},l={kernel:o})=>{var c;let a=(c=n.cmpId)!=null?c:B(),p={data:n!=null&&n.skipInitalQuerying?void 0:r(t),prevData:void 0,version:0},u=e;if(n.debounceMs||n.throttleMs){if(n.debounceMs&&n.throttleMs)throw new Error("Cannot have both debounce and throttle options for any given query!");n.debounceMs?u=b(e,n.debounceMs):n.throttleMs&&(u=R(e,n.throttleMs))}return{result:p,onMounted:()=>{y({queryFn:r,queryInstance:{instanceKey:a,readTrigger:u,paramsObj:t||{},options:n,result:p}},l)},onBeforeUnmount:()=>{g({queryFn:r,queryInstance:{instanceKey:a,readTrigger:void 0,paramsObj:t||{},options:n,result:{data:void 0,prevData:void 0,version:0}}},l)}}};export{f as KernelStore,y as addQuery,D as addRule,m as afterWrite,A as clearAllRules,E as getExecStack,v as getQueryPlan,B as getSortedID,o as kernelStore,g as removeQuery,w as removeRule,ne as subscribe,$ as trigger};
